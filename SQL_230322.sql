DROP TABLE DEPT_TEMP;

CREATE TABLE DEPT_TEMP
AS (SELECT*FROM DEPT);


SELECT * FROM DEPT_TEMP;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (50, 'DATABASE','SEOUL')
;


INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (70, 'WEB',NULL)
;

INSERT INTO DEPT_TEMP (DEPTNO, DNAME, LOC)
VALUES (80, 'MOBILE','')
;


COMMIT;
CREATE TABLE EMP_TEMP
AS (SELECT*FROM EMP WHERE 1<>1);

SELECT * FROM EMP_TEMP;

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (9999, '홍길동','PRESIDENT', NULL, '2001-01-01', 6000, 500, 10);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (2111, '이순신','MANAGER', 9999, TO_DATE('07/01/2001','DD/MM/YYYY'), 4000, NULL, 20);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES (3111, '심청이','MANAGER', 9999, SYSDATE, 4000, NULL, 30);

INSERT INTO EMP_TEMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
	SELECT E.EMPNO,E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO
	FROM EMP E, SALGRADE S
	WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL AND S.GRADE = 1;

SELECT * FROM EMP_TEMP;
SELECT * FROM EMP;
SELECT * FROM SALGRADE;


--UPDATE문 : 필터된 데이터에 대해서 레코드 값을 수정

CREATE TABLE DEPT_TEMP2   --테스트 개발을 위한 임시 테이블 생성
AS (SELECT * FROM DEPT)
;

SELECT * FROM DEPT_TEMP2   --테스트 개발을 위한 임시 테이블 확인
;

SELECT * 
FROM EMP
WHERE ROWNUM <3;

/*
 * UPDATE .....
 * SET..... (기본구문)
 * WHERE 이게 세트
 */

CREATE TABLE DEPT_TEMP2
AS (SELECT * FROM DEPT);

SELECT *
FROM DEPT_TEMP2
;

UPDATE DEPT_TEMP2
SET DNAME='DATABASE' , LOC = 'SEOUL'
WHERE DEPTNO = 40
;

/*
서브쿼리 사용하여 UPDATE 
*/
UPDATE DEPT_TEMP2  --다시 기본 테이블에서 원복
  SET (DNAME, LOC) = ( SELECT DNAME, LOC  /*TUPLE은 데이터타입,컬럼순서를 바꿀수도 없다*/
					   FROM DEPT 
					   WHERE DEPTNO=40
					 ) 
  WHERE DEPTNO=40
;

ROLLBACK;


/*
 * DELETE 구문으로 테이블에서 값을 제거
 * 보통의 경우, DELETE보다는 UPDATE 구문으로 상태 값을 변경
 * 대부분의 경우(또는 반드시) WHERE 같이
 * 예시: 근무/휴직/퇴사 등의 유형으로 값을 변경
 */

CREATE TABLE EMP_TEMP2 
AS(SELECT * FROM EMP);

SELECT *
  FROM EMP_TEMP2;
 
COMMIT;
 
DELETE FROM EMP_TEMP2
WHERE JOB = 'MANAGER'
;  --인사팀에서 명령 실행

COMMIT; 

/*
 * WHERE 조건을 좀더 복잡하게 주고
 * DELETE 실행
 */
				
DELETE FROM EMP_TEMP2  --HR개발테스트를 위한 임시 테이블
WHERE EMPNO IN (SELECT EMPNO
	FROM EMP_TEMP2 E, SALGRADE S
	WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL 
			AND S.GRADE =3
			AND DEPTNO =30)
;


/*
 * CREATE 문을 정의 : 기존에 없는 테이블 구조를 생성
 * 
 * 데이터는 없고, 테이블의 컬럼과 데이터타입, 제약 조건 등의 구조를 생성
 */

CREATE TABLE EMP_NEW
(
	  EMPNO	   NUMBER(6)
	, ENAME    VARCHAR(10)
	, JOB      VARCHAR(9)
	, MGR      NUMBER(6)
	, HIREDATE DATE
	, SALGRADE NUMBER(7,2)
	, COMM     NUMBER(7,2)
	, DEPTNO   NUMBER(2)	
)
;				

SELECT *
	FROM EMP 
	WHERE ROWNUM <= 5
	;


SELECT *
	FROM EMP_NEW 
	;

ALTER TABLE EMP_NEW
  ADD HP VARCHAR(20)
  ;
 
 
 ALTER TABLE EMP_NEW 
  RENAME COLUMN HP TO TEL_NO  --잘못된 컬럼명 HP를 고객 전화번호 TEL_NO로 수정
  ;
  
 ALTER TABLE EMP_NEW  -- 새로 인수한 회사 직원 관리 테이블
  MODIFY EMPNO NUMBER(5)  --직원수가 많아 기존 4자리에서 5자리로 수정
  ;
  
 
 ALTER TABLE EMP_NEW 
  DROP COLUMN TEL_NO
  ;
  
/*
 * SEQUENCE 일련번호를 생성하여 테이블 관리를 편리하게 하고자 함
 */
CREATE SEQUENCE SEQ_DETPSEQ
	INCREMENT BY 1
	START WITH 1
	MAXVALUE 999
	MINVALUE 1
	NOCYCLE NOCACHE
	;

INSERT INTO DEPT_TEMP2(DEPTNO,DNAME,LOC)
VALUES (SEQ_DETPSEQ.NEXTVAL,'DATABASE','SEOUL');

INSERT INTO DEPT_TEMP2(DEPTNO,DNAME,LOC)
VALUES (SEQ_DETPSEQ.NEXTVAL,'WEB','BUSAN');

INSERT INTO DEPT_TEMP2(DEPTNO,DNAME,LOC)
VALUES (SEQ_DETPSEQ.NEXTVAL, 'MOBILE','ILSAN');

SELECT *
	FROM DEPT_TEMP2
	;

/*
 * 제약 조건 (CONSTRAINTS) 지정
 * 
 * 테이블을 생성할 때, 테이블 컬럼별 제약조건을 설정
 * 
 * 자주 사용되는 중요한 제약조건 유형
 * NOT NULL
 * UNIQUE
 * PK
 */
	
CREATE TABLE LOGIN 
(
	 LOG_ID      VARCHAR2(20)      NOT NULL
	,LOG_PWD    VARCHAR2(20)      NOT NULL
	,TEL         VARCHAR2(20)
);
SELECT *
FROM LOGIN;

ALTER TABLE LOGIN
RENAME COLUMN LONG_PWD TO LOGIN_PWD;

ALTER TABLE LOGIN
RENAME COLUMN LOGIN_PWD TO LOG_PWD;


INSERT INTO LOGIN (LOG_ID, LOG_PWD, TEL)
VALUES('TEST01','1234','010-1234-2342')
;

UPDATE LOGIN 
SET LOGIN_PWD = NULL
WHRER LOGIN_ID = 'TEST01'
;

ALTER TABLE LOGIN 
 MODIFY(TEL NOT NULL);

UPDATE LOGIN 
 SET TEL = '010-2345-1234'
 WHERE LOGIN_ID = 'TEST01'
;

CREATE TABLE LOGIN2(
	 LOG_ID      VARCHAR2(20)      CONSTRAINT TBLNN2_LGNID_NN NOT NULL
	,LOG_PWD     VARCHAR2(20)      CONSTRAINT TBLNN2_LGNPW_NN NOT NULL
	,TEL         VARCHAR2(20) );

SELECT OWNER
		, CONSTRAINT_NAME
		, CONSTRAINT_TYPE
		, TABLE_NAME
	FROM USER_CONSTRAINTS;

ALTER TABLE LOGIN2
MODIFY(TEL CONSTRAINT TBLNN_TEL_NN NOT NULL);

SELECT OWNER, CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'LOGIN2';

ALTER TABLE LOGIN2
DROP CONSTRAINT TBLNN_TEL_NN;

CREATE TABLE LOGIN_UNIQUE(
	 LOG_ID      VARCHAR2(20)  UNIQUE
	,LOG_PWD     VARCHAR2(20)  NOT NULL
	,TEL         VARCHAR2(20) );

SELECT OWNER
		, CONSTRAINT_NAME
		, CONSTRAINT_TYPE
		, TABLE_NAME
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'LOGIN_UNIQUE';

INSERT INTO LOGIN_UNIQUE(LOG_ID,LOG_PWD, TEL)
VALUES('TEST01','PW01','010-1234-4566');

INSERT INTO LOGIN_UNIQUE(LOG_ID,LOG_PWD, TEL)
VALUES('TEST02','PW01','010-1234-4566');


INSERT INTO LOGIN_UNIQUE(LOG_ID,LOG_PWD, TEL)
VALUES(NULL,'PW01','010-1234-4566');

SELECT *FROM LOGIN_UNIQUE;

UPDATE LOGIN_UNIQUE
SET LOG_ID='TEST_ID_NEW'
WHERE LOG_ID IS NULL;

SELECT OWNER
		, CONSTRAINT_NAME
		, CONSTRAINT_TYPE
		, TABLE_NAME
	FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'LOGIN%';

ALTER TABLE LOGIN_UNIQUE
MODIFY(TEL UNIQUE);

UPDATE LOGIN_UNIQUE
SET TEL = NULL;

SELECT * FROM LOGIN_UNIQUE;

ALTER TABLE LOGIN_UNIQUE
MODIFY(TEL UNIQUE);


/*
 * PK (주키, PRIMARY KEY) : 테이블을 설명하는 가장 중요한 키
 * 
 * NOT NULL + UNIQUE + INDEX
 */


CREATE TABLE LOG_PK
(
	 LOG_ID      VARCHAR2(20)    PRIMARY KEY  
	,LOG_PWD     VARCHAR2(20)    NOT NULL
	,TEL         VARCHAR2(20) 
);

INSERT INTO LOG_PK (LOG_ID , LOG_PWD, TEL)
VALUES ('PK01','PWD01','012-1234-4566');

INSERT INTO LOG_PK (LOG_ID , LOG_PWD, TEL)
VALUES (NULL,'PWD02','012-1334-3566');

SELECT *
 FROM EMP_TEMP ;

/*존재하지 않는 부서번호를 EMP_TEMP 테이블에 입력을 시도
*/
INSERT INTO EMP_TEMP (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES (3333,'GHOST','SURPRISE',9999,SYSDATE,1200,NULL,99)
;

/*존재하지 않는 부서번호를 EMP 테이블에 입력을 시도
*/

INSERT INTO EMP (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO)
VALUES (3333,'GHOST','SURPRISE',9999,SYSDATE,1200,NULL,99)
;


/*INDEX 빠른 검색을 위한 색인
 * 
 * 장점: 순식간에 원하는 값을 찾아준다
 * 단점: 입력과 출력이 잦은 경우, 인덱스가 설정된 테이블의 속도가 저하된다.
 */

-- 특정 직군에 해당하는 직원을 빠르게 찾기 위한 색인지정
CREATE INDEX IDX_EMP_JOB
ON EMP(JOB)
;

SELECT *
FROM USER_INDEXES 
--WHERE TABLE_NAME IN('EMP','DEPT')
;

/* 
 * VIEW
 */
CREATE VIEW vw_emp
AS (SELECT empno, ename, job,deptno
		FROM emp 
		WHERE deptno = 10)
		;
	
SELECT *
FROM vw_emp
;

SELECT *
FROM user_views
WHERE view_name = 'VW_EMP' --테이블은 대문자로 표기
;

SELECT rownum, e.*
FROM emp e
ORDER BY sal DESC;

SELECT rownum, e.*
from(SELECT*
		FROM emp e
		ORDER BY sal desc)E;
		
	
/*
 * 오라클 DBMS에서 관리하는 관리 테이블 리스트 출력
 */
SELECT *
	FROM DICT
	WHERE table_name LIKE 'USER_%'; -- %와일드 카드;
	
